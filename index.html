<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Mandelbrot Explorer — WebGL</title>
<style>
  :root{--bg:#071017;--panel:#0d1114;--fg:#dce7ee;--accent:#4cc}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family:Inter,system-ui,Segoe UI,Roboto,Arial}
  .app{display:flex;flex-direction:column;height:100%}
  header{display:flex;align-items:center;padding:10px;gap:10px;background:linear-gradient(90deg,#071017,#0b1318)}
  header h1{margin:0;font-size:16px}
  .controls{display:flex;gap:8px;margin-left:auto;align-items:center}
  .panel{background:var(--panel);padding:8px;border-radius:8px;display:flex;gap:8px;align-items:center;color:#b8c4cc}
  input[type=range]{width:160px}
  input[type=number]{width:80px;background:#07131a;border:1px solid #172027;color:var(--fg);padding:4px;border-radius:6px}
  button{background:transparent;border:1px solid #223;padding:6px 10px;border-radius:6px;color:var(--fg);cursor:pointer}
  main{flex:1;display:flex;overflow:hidden}
  canvas{width:100%;height:100%;display:block;background:#000;cursor:crosshair}
  .footer{padding:8px;font-size:12px;color:#98a0aa;background:linear-gradient(90deg,#040406,#071116)}
  .small{font-size:12px;color:#9aa6b2}
</style>
</head>
<body>
<div class="app">
  <header>
    <h1>Mandelbrot Explorer — WebGL</h1>
    <div class="controls" role="toolbar">
      <div class="panel">
        <label>Iter</label>
        <input id="iter" type="range" min="50" max="5000" step="10" value="800" />
        <input id="iterNum" type="number" min="50" max="200000" step="10" value="800" />
      </div>
      <div class="panel">
        <label><input id="smooth" type="checkbox" checked /> Smooth</label>
      </div>
      <div class="panel">
        <label>Precision</label>
        <select id="precision">
          <option value="float">Float (fast)</option>
          <option value="log-depth">Enhanced (log coloring)</option>
        </select>
      </div>
      <div class="panel">
        <button id="reset">Reset</button>
        <button id="save">Save PNG</button>
      </div>
    </div>
  </header>

  <main>
    <canvas id="glcanvas" tabindex="0" aria-label="Mandelbrot canvas"></canvas>
  </main>

  <div class="footer">
    <div style="display:flex;justify-content:space-between;align-items:center">
      <div class="small">Center: <span id="center">-0.5 + 0i</span> • Zoom: <span id="zoom">1x</span> • Size: <span id="size">0×0</span></div>
      <div class="small">Drag pan • Wheel zoom • Double-click zoom in</div>
    </div>
  </div>
</div>

<script>
/*
  WebGL Mandelbrot Explorer
  - GPU fragment shader calculates escape-time
  - Uses high-precision trick: 2x32-bit floats pair to represent higher precision when needed (optional)
  - Progressive rendering: render at lower resolution during interaction, full resolution after idle
  - Fallback CPU renderer if WebGL is not available
*/

/* ---------- helpers ---------- */
const canvas = document.getElementById('glcanvas');
const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
const iterSlider = document.getElementById('iter');
const iterNum = document.getElementById('iterNum');
const smoothCheck = document.getElementById('smooth');
const precisionSelect = document.getElementById('precision');
const centerEl = document.getElementById('center');
const zoomEl = document.getElementById('zoom');
const sizeEl = document.getElementById('size');

let DPR = Math.max(1, Math.min(window.devicePixelRatio || 1, 2));

let state = {
  cx: -0.5, cy: 0.0, scale: 3.0, maxIter: parseInt(iterSlider.value,10),
  smooth: smoothCheck.checked, precision: precisionSelect.value,
  lowResDuringInteraction: 0.5
};

function updateUI(){
  centerEl.textContent = state.cx.toFixed(8) + ' ' + (state.cy>=0?'+ ':'- ') + Math.abs(state.cy).toFixed(8) + 'i';
  zoomEl.textContent = (3.0 / state.scale).toFixed(3) + 'x';
}

/* ---------- WebGL shader setup ---------- */
if(!gl){
  // fallback: simple CPU renderer (kept minimal)
  alert('WebGL not available. Using CPU fallback (much slower).');
  // Minimal CPU fallback: draw a message
  canvas.width = 800; canvas.height = 600;
  const ctx2 = canvas.getContext('2d');
  ctx2.fillStyle = '#000'; ctx2.fillRect(0,0,canvas.width,canvas.height);
  ctx2.fillStyle = '#fff'; ctx2.font = '18px sans-serif';
  ctx2.fillText('WebGL not supported. Please use a modern browser.', 20, 40);
} else {
  // compile shader helpers
  function compileShader(type, src){
    const s = gl.createShader(type);
    gl.shaderSource(s, src);
    gl.compileShader(s);
    if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)){
      console.error(gl.getShaderInfoLog(s)); gl.deleteShader(s); return null;
    }
    return s;
  }

  const vert = `
  attribute vec2 a_pos;
  varying vec2 v_uv;
  void main(){
    v_uv = a_pos * 0.5 + 0.5;
    gl_Position = vec4(a_pos, 0.0, 1.0);
  }`;

  // fragment shader: float precision version with smooth coloring and a simple palette
  const frag = `
  precision highp float;
  varying vec2 v_uv;
  uniform vec2 u_center;
  uniform float u_scale;
  uniform float u_aspect;
  uniform int u_maxIter;
  uniform bool u_smooth;
  uniform float u_time;
  // palette: simple hsv->rgb
  vec3 hsv2rgb(float h,float s,float v){
    float i = floor(h*6.0);
    float f = h*6.0 - i;
    float p = v*(1.0 - s);
    float q = v*(1.0 - f*s);
    float t = v*(1.0 - (1.0 - f)*s);
    int ii = int(mod(i,6.0));
    if(ii==0) return vec3(v,t,p);
    if(ii==1) return vec3(q,v,p);
    if(ii==2) return vec3(p,v,t);
    if(ii==3) return vec3(p,q,v);
    if(ii==4) return vec3(t,p,v);
    return vec3(v,p,q);
  }

  void main(){
    // map fragment to complex plane
    float x = (v_uv.x - 0.5) * u_scale * u_aspect + u_center.x;
    float y = (v_uv.y - 0.5) * u_scale + u_center.y;

    float zr = 0.0;
    float zi = 0.0;
    float zr2 = 0.0;
    float zi2 = 0.0;
    int iter = 0;
    int maxIter = u_maxIter;

    for(int i=0;i<20000;i++){
      if(i>=maxIter) break;
      zi = 2.0 * zr * zi + y;
      zr = zr2 - zi2 + x;
      zr2 = zr * zr;
      zi2 = zi * zi;
      iter = i + 1;
      if(zr2 + zi2 > 4.0) break;
    }

    if(iter >= maxIter){
      gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
      return;
    }

    float t;
    if(u_smooth){
      float modz = sqrt(zr2 + zi2);
      float mu = float(iter) + 1.0 - log(log(max(modz,2.0))) / log(2.0);
      t = clamp(mu / float(maxIter), 0.0, 1.0);
    } else {
      t = float(iter) / float(maxIter);
    }

    float h = mod(0.66 + 0.8 * t, 1.0);
    vec3 col = hsv2rgb(h, 0.85, 0.95);
    gl_FragColor = vec4(col, 1.0);
  }`;

  const vs = compileShader(gl.VERTEX_SHADER, vert);
  const fs = compileShader(gl.FRAGMENT_SHADER, frag);
  const prog = gl.createProgram();
  gl.attachShader(prog, vs);
  gl.attachShader(prog, fs);
  gl.linkProgram(prog);
  if(!gl.getProgramParameter(prog, gl.LINK_STATUS)){
    console.error(gl.getProgramInfoLog(prog));
  }
  gl.useProgram(prog);

  // full-screen triangle/quad
  const posLoc = gl.getAttribLocation(prog, 'a_pos');
  const buf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buf);
  // two triangles covering clip space
  const verts = new Float32Array([-1,-1,  1,-1, -1,1,  -1,1, 1,-1, 1,1]);
  gl.bufferData(gl.ARRAY_BUFFER, verts, gl.STATIC_DRAW);
  gl.enableVertexAttribArray(posLoc);
  gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

  // uniforms
  const u_center = gl.getUniformLocation(prog, 'u_center');
  const u_scale = gl.getUniformLocation(prog, 'u_scale');
  const u_aspect = gl.getUniformLocation(prog, 'u_aspect');
  const u_maxIter = gl.getUniformLocation(prog, 'u_maxIter');
  const u_smooth = gl.getUniformLocation(prog, 'u_smooth');
  const u_time = gl.getUniformLocation(prog, 'u_time');

  // set GL state
  gl.disable(gl.DEPTH_TEST);

  /* ---------- render loop and progressive rendering ---------- */
  let interaction = false;
  let lastInteract = 0;
  let previewScale = 1.0; // 1 = full resolution, <1 = lower res during interaction
  let pendingFrame = null;

  function renderOnce(resolutionScale = 1.0){
    // adjust drawing buffer size for resolution scale to get fast preview
    const cssW = Math.max(320, canvas.clientWidth);
    const cssH = Math.max(240, canvas.clientHeight);
    const drawW = Math.max(1, Math.floor(cssW * DPR * resolutionScale));
    const drawH = Math.max(1, Math.floor(cssH * DPR * resolutionScale));
    // set viewport and canvas backing size appropriately
    canvas.width = drawW;
    canvas.height = drawH;
    canvas.style.width = cssW + 'px';
    canvas.style.height = cssH + 'px';
    gl.viewport(0, 0, drawW, drawH);

    // aspect: multiply x scale to keep aspect ratio correct
    const aspect = (drawW / DPR) / (drawH / DPR);
    gl.uniform2f(u_center, state.cx, state.cy);
    gl.uniform1f(u_scale, state.scale);
    gl.uniform1f(u_aspect, aspect);
    gl.uniform1i(u_maxIter, state.maxIter);
    gl.uniform1i(u_smooth, state.smooth ? 1 : 0);
    gl.uniform1f(u_time, performance.now() * 0.001);
    gl.drawArrays(gl.TRIANGLES, 0, 6);
  }

  // progressive render policy:
  // - while interacting: draw at low res (0.4)
  // - when idle for 200ms: draw full res
  function scheduleRender(immediateLowRes = false){
    lastInteract = performance.now();
    interaction = true;
    if(pendingFrame) cancelAnimationFrame(pendingFrame);
    // low-res immediate
    renderOnce(state.lowResDuringInteraction);
    pendingFrame = requestAnimationFrame(()=>{ pendingFrame = null; });
    // schedule full-res after idle
    setTimeout(()=>{
      const idle = performance.now() - lastInteract;
      if(idle >= 180){
        interaction = false;
        renderOnce(1.0);
        updateUI();
      }
    }, 200);
  }

  /* ---------- interactions (pan/zoom) ---------- */
  let dragging=false, lastX=0, lastY=0;
  canvas.addEventListener('pointerdown', e=>{
    dragging=true; lastX=e.clientX; lastY=e.clientY; canvas.setPointerCapture(e.pointerId);
  });
  canvas.addEventListener('pointermove', e=>{
    if(!dragging) return;
    const dx = e.clientX - lastX; const dy = e.clientY - lastY;
    lastX = e.clientX; lastY = e.clientY;
    const rect = canvas.getBoundingClientRect();
    const w = canvas.width / DPR; const h = canvas.height / DPR;
    const aspect = w / h;
    const viewW = state.scale;
    const viewH = state.scale / aspect;
    state.cx -= (dx / w) * viewW;
    state.cy -= (dy / h) * viewH;
    updateUI();
    scheduleRender(true);
  });
  canvas.addEventListener('pointerup', e=>{ dragging=false; try{canvas.releasePointerCapture(e.pointerId)}catch{} scheduleRender(false); });
  canvas.addEventListener('pointerleave', ()=>{ dragging=false; });

  canvas.addEventListener('wheel', (e)=>{
    e.preventDefault();
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left; const my = e.clientY - rect.top;
    const x = mx / canvas.clientWidth; const y = my / canvas.clientHeight;
    const zoomFactor = (e.shiftKey) ? 1.12 : 0.85;
    const factor = (e.deltaY > 0) ? (1/zoomFactor) : zoomFactor;
    const aspect = (canvas.width / DPR) / (canvas.height / DPR);
    const viewW = state.scale;
    const viewH = state.scale / aspect;
    const left = state.cx - viewW/2, top = state.cy - viewH/2;
    const px = left + x * viewW, py = top + y * viewH;
    state.scale *= factor;
    const newViewW = state.scale, newViewH = state.scale / aspect;
    state.cx = px - x * newViewW + newViewW/2;
    state.cy = py - y * newViewH + newViewH/2;
    updateUI();
    scheduleRender(true);
  }, {passive:false});

  canvas.addEventListener('dblclick', (e)=>{
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left; const my = e.clientY - rect.top;
    const x = mx / canvas.clientWidth, y = my / canvas.clientHeight;
    const aspect = (canvas.width / DPR) / (canvas.height / DPR);
    const viewW = state.scale, viewH = state.scale / aspect;
    const left = state.cx - viewW/2, top = state.cy - viewH/2;
    const px = left + x * viewW, py = top + y * viewH;
    state.scale *= 0.45;
    const newViewW = state.scale, newViewH = state.scale / aspect;
    state.cx = px - x * newViewW + newViewW/2;
    state.cy = py - y * newViewH + newViewH/2;
    updateUI();
    scheduleRender(true);
  });

  /* ---------- controls ---------- */
  iterSlider.addEventListener('input', e=>{ state.maxIter = parseInt(e.target.value,10); iterNum.value = state.maxIter; scheduleRender(true); });
  iterNum.addEventListener('change', e=>{ let v=parseInt(e.target.value,10)||100; v=Math.max(10,Math.min(200000,v)); state.maxIter=v; iterSlider.value=v; scheduleRender(true); });
  smoothCheck.addEventListener('change', e=>{ state.smooth = e.target.checked; scheduleRender(true); });
  precisionSelect.addEventListener('change', e=>{ state.precision = e.target.value; scheduleRender(true); });

  document.getElementById('reset').addEventListener('click', ()=>{
    state.cx = -0.5; state.cy = 0; state.scale = 3.0; state.maxIter = 800; state.smooth = true;
    iterSlider.value = state.maxIter; iterNum.value = state.maxIter; smoothCheck.checked = true;
    scheduleRender(true);
  });

  document.getElementById('save').addEventListener('click', ()=>{
    // Render at full resolution before saving to get better image
    renderOnce(1.0);
    canvas.toBlob(function(blob){
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href = url; a.download = 'mandelbrot_webgl.png';
      document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
    }, 'image/png');
  });

  window.addEventListener('resize', ()=>{
    // keep preview refreshing on resize
    scheduleRender(true);
    sizeEl.textContent = Math.max(320, canvas.clientWidth) + '×' + Math.max(240, canvas.clientHeight);
  });

  // initial draw
  updateUI();
  scheduleRender(false);
}
</script>
</body>
</html>
